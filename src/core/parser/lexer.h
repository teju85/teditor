#pragma once

#include <stdint.h>
#include <core/pos2d.h>
#include <vector>
#include <unordered_map>
#include <unordered_set>
#include <ostream>
#include "core/utils.h"

namespace teditor {
namespace parser {

/** Represents a token that is being generated by the Lexer */
struct Token {
  /**
   * token type. Custom parsers are free to define their own types for their
   * internal use. But from an interface perspective, it'll always be an integer
   * for faster lookup.
   */
  uint32_t type;
  /** start of this token in the input stream */
  Point start;
  /** end of this token in the input stream */
  Point end;

  bool isEof() const { return type == End; }

  /** special reserved token for denoting EOF */
  static const uint32_t End;
  /** special reserved token for denoting unknown token */
  static const uint32_t Unknown;
  /** special reserved token for denoting root node */
  static const uint32_t Root;

  friend std::ostream& operator<<(std::ostream& os, const Token& tok);
};  // struct Token


/** A regex string and a unique type to identify a token during lexing */
struct TokenDef {
  uint32_t type;
  std::string regex;
  std::string name;
};
typedef std::vector<TokenDef> TokenDefs;


class Scanner;
struct NFA;
/** Base lexing class for tokenizing the input stream */
struct Lexer {
  Lexer(const TokenDefs& t);
  virtual ~Lexer();
  virtual Token next(Scanner* sc);
  Token next(Scanner* sc, const std::unordered_set<uint32_t>& ignoreTypes);
  Token next(Scanner* sc, uint32_t ignoreType);
  const char* token2str(uint32_t tok) const;

 private:
  std::vector<NFA*> nfas;
  TokenDefs tokenDefs;
  std::unordered_map<uint32_t, std::string> names;

  void reset();
  bool step(char c, const Point& pt, int& nActives, int& nSoleMatches,
            int& nMatches);
  void getLongestMatchingToken(Token& ret, bool lastRemainingState);
};  // struct Lexer


}  // namespace parser
}  // namespace teditor
