#pragma once

#include <stdint.h>
#include <core/pos2d.h>
#include <vector>
#include <unordered_set>

namespace teditor {
namespace parser {

/** Represents a token that is being generated by the Lexer */
struct Token {
  /**
   * token type. Custom parsers are free to define their own types for their
   * internal use. But from an interface perspective, it'll always be an integer
   * for faster lookup.
   */
  uint32_t type;
  /** start of this token in the input stream */
  Point start;
  /** end of this token in the input stream */
  Point end;

  bool isEof() const { return type == End; }

  /** special reserved token for denoting EOF */
  static const uint32_t End;
  /** special reserved token for denoting unknown token */
  static const uint32_t Unknown;
  /** special reserved token for denoting root node */
  static const uint32_t Root;
};  // struct Token


/** A regex string and a unique type to identify a token during lexing */
struct TokenDef {
  uint32_t type;
  std::string regex;
};
typedef std::vector<TokenDef> TokenDefs;


class Scanner;
struct NFA;
/** Base lexing class for tokenizing the input stream */
struct Lexer {
  Lexer(const TokenDefs& t);
  virtual ~Lexer();
  virtual Token next(Scanner* sc);
  Token nextWithIgnore(Scanner* sc,
                       const std::unordered_set<uint32_t>& ignoreTypes);
  Token nextWithIgnore(Scanner* sc, uint32_t ignoreType);

 private:
  std::vector<NFA*> nfas;
  TokenDefs tokenDefs;

  void reset();
  bool step(char c, const Point& pt, int& nActives, int& nSoleMatches,
            int& nMatches);
  void getLongestMatchingToken(Token& ret, bool lastRemainingState);
};  // struct Lexer


}  // namespace parser
}  // namespace teditor
